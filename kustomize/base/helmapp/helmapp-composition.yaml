apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: helmapplication-argocd
  namespace: crossplane-system
spec:
  # Reference to the XRD
  compositeTypeRef:
    apiVersion: dip.io/v1alpha1
    kind: HelmApplication
  
  mode: Pipeline
  
  pipeline:
  # Load all EnvironmentConfigs using Selector with Multiple mode
  - step: load-environment-configs
    functionRef:
      name: function-environment-configs
    input:
      apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
      kind: Input
      spec:
        environmentConfigs:
        - type: Reference
          ref:
            name: hsp-addons
        - type: Selector
          selector:
            mode: Multiple
            matchLabels:
              - key: config
                type: Value
                value: hsp-addons
  
  - step: render-argocd-app
    functionRef:
      name: function-go-templating
    input:
      apiVersion: gotemplating.fn.crossplane.io/v1beta1
      kind: GoTemplate
      source: Inline
      inline:
        template: |
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            namespace: {{ .observed.composite.resource.metadata.namespace }}
            name: {{ .observed.composite.resource.metadata.name }}
            annotations:
              gotemplating.fn.crossplane.io/composition-resource-name: argocd-app
            finalizers:
            - resources-finalizer.argocd.argoproj.io
          spec:
            project: {{ default "default" .observed.composite.resource.spec.project }}
            source:
              repoURL: {{ .observed.composite.resource.spec.repoURL }}
              targetRevision: {{ .observed.composite.resource.spec.targetRevision }}
              {{- if and .observed.composite.resource.spec.chartName (not (hasPrefix "oci://" .observed.composite.resource.spec.repoURL)) }}
              chart: {{ .observed.composite.resource.spec.chartName }}
              {{- end }}
              {{- if .observed.composite.resource.spec.path }}
              path: {{ .observed.composite.resource.spec.path }}
              {{- end }}
              helm:
                releaseName: {{ default .observed.composite.resource.metadata.name .observed.composite.resource.spec.helm.releaseName }}
                valuesObject:
                  {{- if .observed.composite.resource.spec.helm.valuesObject }}
                  {{- range $key, $value := .observed.composite.resource.spec.helm.valuesObject }}
                  {{ $key }}: {{ toJson $value }}
                  {{- end }}
                  {{- end }}
                  {{- if (index .context "apiextensions.crossplane.io/environment") }}
                  {{- $env := index .context "apiextensions.crossplane.io/environment" }}
                  {{- $filterKeys := .observed.composite.resource.spec.withConfigKeys }}
                  environmentConfig:
                    {{- if $filterKeys }}
                    {{- /* Build filtered config based on exact and nested key matches */ -}}
                    {{- range $filterKey := $filterKeys }}
                    {{- if contains "." $filterKey }}
                    {{- /* Handle nested key like "eks.clusterName" */ -}}
                    {{- $parts := splitList "." $filterKey }}
                    {{- $topKey := index $parts 0 }}
                    {{- $nestedPath := join "." (rest $parts) }}
                    {{- if (index $env $topKey) }}
                    {{- $topValue := index $env $topKey }}
                    {{- if (typeOf $topValue | contains "map") }}
                    {{- /* Navigate to nested value */ -}}
                    {{- $currentValue := $topValue }}
                    {{- $pathParts := splitList "." $nestedPath }}
                    {{- $found := true }}
                    {{- range $pathPart := $pathParts }}
                    {{- if and $found (typeOf $currentValue | contains "map") }}
                    {{- if (index $currentValue $pathPart) }}
                    {{- $currentValue = index $currentValue $pathPart }}
                    {{- else }}
                    {{- $found = false }}
                    {{- end }}
                    {{- else }}
                    {{- $found = false }}
                    {{- end }}
                    {{- end }}
                    {{- if $found }}
                    {{ $nestedPath }}: {{ toJson $currentValue }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* Handle exact top-level key */ -}}
                    {{- if and (index $env $filterKey) (ne $filterKey "apiVersion") (ne $filterKey "kind") }}
                    {{ $filterKey }}: {{ toJson (index $env $filterKey) }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* No filter - include all keys */ -}}
                    {{- range $key, $value := $env }}
                    {{- if and (ne $key "apiVersion") (ne $key "kind") }}
                    {{ $key }}: {{ toJson $value }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    # Duplicate eks fields, if any, at top level for easier access
                    {{- if (index $env "eks") }}
                    {{- $eks := index $env "eks" }}
                    {{- if (typeOf $eks | contains "map") }}
                    {{- if $filterKeys }}
                    {{- /* Apply filtering to eks fields - check if filter keys exist in eks object */ -}}
                    {{- $includeAllEks := false }}
                    {{- $eksFieldsToInclude := list }}
                    {{- range $filterKey := $filterKeys }}
                    {{- if eq $filterKey "eks" }}
                    {{- $includeAllEks = true }}
                    {{- else if (index $eks $filterKey) }}
                    {{- /* Filter key matches an eks field directly */ -}}
                    {{- $eksFieldsToInclude = append $eksFieldsToInclude $filterKey }}
                    {{- end }}
                    {{- end }}
                    {{- if $includeAllEks }}
                    {{- /* Include all eks fields */ -}}
                    {{- range $eksKey, $eksValue := $eks }}
                    {{ $eksKey }}: {{ toJson $eksValue }}
                    {{- end }}
                    {{- else if $eksFieldsToInclude }}
                    {{- /* Include only specific eks fields */ -}}
                    {{- range $eksField := $eksFieldsToInclude }}
                    {{ $eksField }}: {{ toJson (index $eks $eksField) }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* No filter - include all eks fields */ -}}
                    {{- range $eksKey, $eksValue := $eks }}
                    {{ $eksKey }}: {{ toJson $eksValue }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                  {{- end }}
            destination:
              server: https://kubernetes.default.svc
              namespace: {{ .observed.composite.resource.metadata.namespace }}
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
              syncOptions:
              - CreateNamespace=true
  
  # NOTE: function-auto-ready cannot detect ArgoCD Application health status
  # because it uses custom .status.health.status field instead of standard Kubernetes conditions
  # Tracking issue: https://github.com/crossplane-contrib/function-auto-ready/issues/29
  - step: auto-ready
    functionRef:
      name: function-auto-ready