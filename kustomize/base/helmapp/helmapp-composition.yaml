apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: helmapplication-argocd
  namespace: crossplane-system
spec:
  # Reference to the XRD
  compositeTypeRef:
    apiVersion: dip.io/v1alpha1
    kind: HelmApplication
  
  mode: Pipeline
  
  pipeline:
  # Load all EnvironmentConfigs using Selector with Multiple mode
  - step: load-environment-configs
    functionRef:
      name: function-environment-configs
    input:
      apiVersion: environmentconfigs.fn.crossplane.io/v1beta1
      kind: Input
      spec:
        environmentConfigs:
        - type: Reference
          ref:
            name: hsp-addons
        - type: Selector
          selector:
            mode: Multiple
            matchLabels:
              - key: config
                type: Value
                value: dip-software    
        - type: Selector
          selector:
            mode: Multiple
            matchLabels:
              - key: config
                type: Value
                value: hsp-addons
  
  - step: render-argocd-app
    functionRef:
      name: function-go-templating
    input:
      apiVersion: gotemplating.fn.crossplane.io/v1beta1
      kind: GoTemplate
      source: Inline
      inline:
        template: |
          {{- /* Define supported environment variables for substitution */ -}}
          {{- $supportedEnvVars := list "resourcePrefix" "clusterFqdn" "accountId" "region" "partition" "oidcProvider" "oidcProviderArn" -}}
          
          {{- /* Function to replace ${variableName} in a string with environment config values */ -}}
          {{- define "replaceEnvVars" -}}
            {{- $value := index . "value" -}}
            {{- $env := index . "env" -}}
            {{- $supportedVars := index . "supportedVars" -}}
            {{- $result := $value -}}
            {{- range $varName := $supportedVars -}}
              {{- if (index $env $varName) -}}
                {{- $pattern := printf "${%s}" $varName -}}
                {{- $replacement := index $env $varName | toString -}}
                {{- $result = $result | replace $pattern $replacement -}}
              {{- end -}}
            {{- end -}}
            {{- $result -}}
          {{- end -}}
          
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            namespace: {{ .observed.composite.resource.metadata.namespace }}
            name: {{ .observed.composite.resource.metadata.name }}
            annotations:
              gotemplating.fn.crossplane.io/composition-resource-name: argocd-app
              {{- range $key, $value := .observed.composite.resource.metadata.annotations }}
              {{ $key }}: {{ $value | quote }}
              {{- end }}
            finalizers:
            - resources-finalizer.argocd.argoproj.io
          spec:
            project: {{ default "default" .observed.composite.resource.spec.project }}
            source:
              repoURL: {{ .observed.composite.resource.spec.source.repoURL }}
              targetRevision: {{ .observed.composite.resource.spec.source.targetRevision }}
              {{- if and .observed.composite.resource.spec.source.chart (not (hasPrefix "oci://" .observed.composite.resource.spec.source.repoURL)) }}
              chart: {{ .observed.composite.resource.spec.source.chart }}
              {{- end }}
              {{- if .observed.composite.resource.spec.source.path }}
              path: {{ .observed.composite.resource.spec.source.path }}
              {{- end }}
              helm:
                releaseName: {{ default .observed.composite.resource.metadata.name .observed.composite.resource.spec.source.helm.releaseName }}
                {{- if .observed.composite.resource.spec.source.helm.valuesObject }}
                {{- $valuesJson := toJson .observed.composite.resource.spec.source.helm.valuesObject }}
                {{- $env := dict }}
                {{- if (index .context "apiextensions.crossplane.io/environment") }}
                {{- $env = index .context "apiextensions.crossplane.io/environment" }}
                {{- end }}
                {{- $processedJson := $valuesJson }}
                {{- range $varName := $supportedEnvVars }}
                {{- if (index $env $varName) }}
                {{- $pattern := printf "${%s}" $varName }}
                {{- $replacement := index $env $varName | toString }}
                {{- $processedJson = $processedJson | replace $pattern $replacement }}
                {{- end }}
                {{- end }}
                valuesObject:
                {{- range $key, $value := ($processedJson | fromJson) }}
                  {{ $key }}: {{ toJson $value }}
                {{- end }}
                {{- end }}
                  {{- if (index .context "apiextensions.crossplane.io/environment") }}
                  {{- $env := index .context "apiextensions.crossplane.io/environment" }}
                  {{- $filterKeys := .observed.composite.resource.spec.source.withConfigKeys }}
                  environmentConfig:
                    {{- if $filterKeys }}
                    {{- /* Build filtered config based on exact and nested key matches */ -}}
                    {{- range $filterKey := $filterKeys }}
                    {{- if contains "." $filterKey }}
                    {{- /* Handle nested key like "eks.clusterName" */ -}}
                    {{- $parts := splitList "." $filterKey }}
                    {{- $topKey := index $parts 0 }}
                    {{- $nestedPath := join "." (rest $parts) }}
                    {{- if (index $env $topKey) }}
                    {{- $topValue := index $env $topKey }}
                    {{- if (typeOf $topValue | contains "map") }}
                    {{- /* Navigate to nested value */ -}}
                    {{- $currentValue := $topValue }}
                    {{- $pathParts := splitList "." $nestedPath }}
                    {{- $found := true }}
                    {{- range $pathPart := $pathParts }}
                    {{- if and $found (typeOf $currentValue | contains "map") }}
                    {{- if (index $currentValue $pathPart) }}
                    {{- $currentValue = index $currentValue $pathPart }}
                    {{- else }}
                    {{- $found = false }}
                    {{- end }}
                    {{- else }}
                    {{- $found = false }}
                    {{- end }}
                    {{- end }}
                    {{- if $found }}
                    {{ $nestedPath }}: {{ toJson $currentValue }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* Handle exact top-level key */ -}}
                    {{- if and (index $env $filterKey) (ne $filterKey "apiVersion") (ne $filterKey "kind") }}
                    {{ $filterKey }}: {{ toJson (index $env $filterKey) }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* No filter - include all keys */ -}}
                    {{- range $key, $value := $env }}
                    {{- if and (ne $key "apiVersion") (ne $key "kind") }}
                    {{ $key }}: {{ toJson $value }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    # Duplicate eks fields, if any, at top level for easier access
                    {{- if (index $env "eks") }}
                    {{- $eks := index $env "eks" }}
                    {{- if (typeOf $eks | contains "map") }}
                    {{- if $filterKeys }}
                    {{- /* Apply filtering to eks fields - check if filter keys exist in eks object */ -}}
                    {{- $includeAllEks := false }}
                    {{- $eksFieldsToInclude := list }}
                    {{- range $filterKey := $filterKeys }}
                    {{- if eq $filterKey "eks" }}
                    {{- $includeAllEks = true }}
                    {{- else if (index $eks $filterKey) }}
                    {{- /* Filter key matches an eks field directly */ -}}
                    {{- $eksFieldsToInclude = append $eksFieldsToInclude $filterKey }}
                    {{- end }}
                    {{- end }}
                    {{- if $includeAllEks }}
                    {{- /* Include all eks fields */ -}}
                    {{- range $eksKey, $eksValue := $eks }}
                    {{ $eksKey }}: {{ toJson $eksValue }}
                    {{- end }}
                    {{- else if $eksFieldsToInclude }}
                    {{- /* Include only specific eks fields */ -}}
                    {{- range $eksField := $eksFieldsToInclude }}
                    {{ $eksField }}: {{ toJson (index $eks $eksField) }}
                    {{- end }}
                    {{- end }}
                    {{- else }}
                    {{- /* No filter - include all eks fields */ -}}
                    {{- range $eksKey, $eksValue := $eks }}
                    {{ $eksKey }}: {{ toJson $eksValue }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    # Duplicate tags.Environment at the root as resourcePrefix for easier access (only if not already set)
                    {{- if not (index $env "resourcePrefix") }}
                    {{- if (index $env "tags") }}
                    {{- $tags := index $env "tags" }}
                    {{- if (typeOf $tags | contains "map") }}
                    {{- if (index $tags "Environment") }}
                    resourcePrefix: {{ toJson (index $tags "Environment") }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                    {{- end }}
                  {{- end }}
            destination:
              server: https://kubernetes.default.svc
              namespace: {{ if .observed.composite.resource.spec.destination }}{{ default .observed.composite.resource.metadata.namespace .observed.composite.resource.spec.destination.namespace }}{{ else }}{{ .observed.composite.resource.metadata.namespace }}{{ end }}
            syncPolicy:
              {{- if .observed.composite.resource.spec.syncPolicy }}
              {{- $syncPolicy := .observed.composite.resource.spec.syncPolicy }}
              {{- if $syncPolicy.automated }}
              automated:
                prune: {{ if hasKey $syncPolicy.automated "prune" }}{{ $syncPolicy.automated.prune }}{{ else }}true{{ end }}
                selfHeal: {{ if hasKey $syncPolicy.automated "selfHeal" }}{{ $syncPolicy.automated.selfHeal }}{{ else }}true{{ end }}
                allowEmpty: {{ if hasKey $syncPolicy.automated "allowEmpty" }}{{ $syncPolicy.automated.allowEmpty }}{{ else }}false{{ end }}
                enabled: {{ if hasKey $syncPolicy.automated "enabled" }}{{ $syncPolicy.automated.enabled }}{{ else }}true{{ end }}
              {{- else }}
              automated:
                prune: true
                selfHeal: true
                allowEmpty: false
                enabled: true
              {{- end }}
              {{- if $syncPolicy.managedNamespaceMetadata }}
              managedNamespaceMetadata:
                {{- if $syncPolicy.managedNamespaceMetadata.labels }}
                labels:
                  {{- range $key, $value := $syncPolicy.managedNamespaceMetadata.labels }}
                  {{ $key }}: {{ $value | quote }}
                  {{- end }}
                {{- end }}
                {{- if $syncPolicy.managedNamespaceMetadata.annotations }}
                annotations:
                  {{- range $key, $value := $syncPolicy.managedNamespaceMetadata.annotations }}
                  {{ $key }}: {{ $value | quote }}
                  {{- end }}
                {{- end }}
              {{- end }}
              {{- if $syncPolicy.retry }}
              retry:
                limit: {{ default 5 $syncPolicy.retry.limit }}
                {{- if $syncPolicy.retry.backoff }}
                backoff:
                  duration: {{ default "5s" $syncPolicy.retry.backoff.duration | quote }}
                  factor: {{ default 2 $syncPolicy.retry.backoff.factor }}
                  maxDuration: {{ default "3m" $syncPolicy.retry.backoff.maxDuration | quote }}
                {{- end }}
              {{- end }}
              {{- if $syncPolicy.syncOptions }}
              syncOptions:
              {{- range $syncPolicy.syncOptions }}
              - {{ . }}
              {{- end }}
              {{- else }}
              syncOptions:
              - CreateNamespace=true
              {{- end }}
              {{- else }}
              automated:
                prune: true
                selfHeal: true
                allowEmpty: false
                enabled: true
              syncOptions:
              - CreateNamespace=true
              {{- end }}
  
  # NOTE: function-auto-ready cannot detect ArgoCD Application health status
  # because it uses custom .status.health.status field instead of standard Kubernetes conditions
  # Tracking issue: https://github.com/crossplane-contrib/function-auto-ready/issues/29
  # 
  # Why It Appears Broken
  # Crossplane's function-auto-ready looks for standard Kubernetes condition fields like:

  # .status.conditions[].type: "Ready"
  # .status.conditions[].status: "True"
  # But ArgoCD Applications use a custom health field:

  # .status.health.status: "Healthy" âœ… (present and healthy)
  # .status.conditions: (empty/not used)
  # This is a known limitation tracked in the upstream issue.
  - step: auto-ready
    functionRef:
      name: function-auto-ready